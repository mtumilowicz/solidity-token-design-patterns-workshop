# solidity-nft-workshops

* references
    * https://www.oreilly.com/library/view/hands-on-smart-contract/9781492045250/
    * https://www.amazon.com/Solidity-Programming-Essentials-building-contracts/dp/1803231181
    * https://www.amazon.com/Beginning-Ethereum-Smart-Contracts-Programming/dp/1484292707
    * https://www.springerprofessional.de/en/ethereum-smart-contract-development-in-solidity/18334966
    * https://www.manning.com/books/blockchain-in-action
    * https://www.packtpub.com/product/mastering-blockchain-programming-with-solidity/9781839218262
    * https://www.algoexpert.io/blockchain/index
    * https://chat.openai.com
    * https://www.linkedin.com/pulse/what-token-burning-how-does-work-azhar-siddiqui
    * https://medium.com/cryptronics/ethereum-smart-contract-security-73b0ede73fa8
    * https://medium.com/immunefi/the-ultimate-guide-to-reentrancy-19526f105ac
    * https://medium.com/neptune-mutual/understanding-signature-replay-attack-cbb70a7f46d8
    * https://slowmist.medium.com/intro-to-smart-contract-security-audit-signature-replay-b71c23910629
    * https://ethereum.stackexchange.com/questions/26/what-is-a-replay-attack
    * https://mirror.xyz/0xbuidlerdao.eth/lOE5VN-BHI0olGOXe27F0auviIuoSlnou_9t3XRJseY
    * https://stackoverflow.com/questions/74164255/x19ethereum-signed-message-n32-prefix-meaning
    * https://ethereum.stackexchange.com/questions/128552/why-would-you-use-a-signed-message-to-verify-the-sender
    * https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7
    * https://medium.com/@kaishinaw/signing-and-verifying-ethereum-messages-f5acd41ca1a8
    * https://github.com/ethers-io/ethers.js/issues/555
    * https://medium.com/@codetractio/walkthrough-of-an-ethereum-improvement-proposal-eip-6fda3966d171
    * https://medium.com/@moplabs/eip-155-with-mopai-75b322962d1b
    * https://medium.com/coinmonks/eip712-a-full-stack-example-e12185b03d54
    * https://medium.com/coinmonks/ethereum-signatures-for-hackers-and-auditors-101-4da766cd6344
    * https://blog.hook.xyz/validate-eip-712/
    * https://ethereum.stackexchange.com/questions/125128/what-is-domain-separator-in-eip712
    * https://kristaps.me/blog/solidity-eip-712-sign-ethers-js/
    * https://dev.to/fassko/what-are-meta-transactions-the-eip-712-standard-and-how-to-sign-a-message-with-metamask-4mil
    * https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26
    * https://0xsomeone.medium.com/b002-solidity-ec-signature-pitfalls-b24a0f91aef4
    * https://nfting.medium.com/what-is-a-replay-attack-23e39ebbb11a
    * https://medium.com/coinmonks/what-the-heck-is-replay-protection-aae910f2a3cb
    * https://medium.com/@MyPaoG/explaining-the-dao-exploit-for-beginners-in-solidity-80ee84f0d470
    * https://medium.com/coinmonks/understanding-and-preventing-short-address-attacks-in-solidity-smart-contracts-3d46a4af9a15
    * https://www.reddit.com/r/ethereum/comments/6r9nhj/cant_understand_the_erc20_short_address_attack/
    * https://medium.com/huzzle/ico-smart-contract-vulnerability-short-address-attack-31ac9177eb6b
    * https://medium.com/coinmonks/what-is-an-nft-and-how-does-it-works-1f85a5734f84
    * https://johankristensson.medium.com/explaining-nft-technology-simplifying-the-basics-89aa539644ee
    * https://medium.com/coinmonks/what-are-nfts-non-fungible-tokens-explained-f3a3d8d18ed7
    * https://webdevelopmentkl.medium.com/nfts-explained-everything-you-need-to-know-323b6fa740d5
    * https://medium.com/analytics-vidhya/what-is-nft-characteristics-and-use-cases-explained-ad7dc77f350f
    * https://medium.com/@BryanBulte/nft-explained-simply-f4daee993096
    * https://medium.com/coinmonks/nft-smart-contract-development-543d712003ef
    * https://medium.com/@dropspace/nft-smart-contract-understanding-the-backbone-of-digital-collectibles-a1f91538c3be
    * https://thebojda.medium.com/code-a-minimalistic-nft-smart-contract-in-solidity-on-ethereum-a-how-to-guide-hacker-noon-5cb72f0891c
    * https://medium.com/@kaishinaw/creating-truly-decentralised-nfts-a-comprehensive-guide-to-erc721-ipfs-b2ae60e312b6
    * https://medium.com/@JaysNotebook/learning-openzeppelin-everything-you-need-to-know-5152a0ad8c4
    * https://medium.com/@ethdapp/using-the-openzeppelin-escrow-library-6384f22caa99
    * https://stermi.medium.com/lets-play-ethernaut-ctf-learning-solidity-security-while-playing-1678bd6db3c4
    * https://www.blockchain-council.org/ethereum/beginners-guide-what-is-erc20/
    * https://ethereum.org/en/developers/docs/standards/tokens/erc-20/
    * https://www.ledger.com/academy/what-are-erc-tokens-and-why-do-we-use-them
    * https://medium.com/@ajaotosinserah/introduction-to-erc20-token-ad30b7422db9
    * https://medium.com/coinmonks/what-are-erc-20-tokens-afcccbc53962
    * https://medium.com/theblockchainhub/erc20-introduction-part-1-e8c2062aed0f
    * https://medium.com/coinmonks/solidity-lesson-28-understanding-the-erc-20-token-928758f053e1
    * https://medium.com/@eiki1212/what-is-erc-20-explanation-of-details-eacf9f288f8b
    * https://medium.com/@ankesh27/erc20-erc721-erc1155-token-standards-explained-f4d240a9c084
    * https://medium.com/geekculture/code-your-own-erc-20-token-1678d9b381da
    * https://medium.com/coinmonks/introduction-to-token-standards-for-ethereum-part-3-extensions-foundations-for-the-erc20-721-22bb727f072c
    * https://medium.com/@lauraguy/what-is-an-erc20-token-d7320369bf76
    * https://medium.com/hackernoon/the-innards-of-an-erc20-token-587c29e9b8a1
    * https://medium.com/@danielque/what-we-learned-from-auditing-the-top-20-erc20-token-contracts-7526ef3b6fb1
    * https://medium.com/@jgm.orinoco/understanding-erc-20-token-contracts-a809a7310aa5
    * https://vitto.cc/how-to-create-and-deploy-an-erc20-token-in-20-minutes/
    * https://medium.com/coinmonks/my-first-erc20-token-7d5d16632818
    * https://medium.com/@infuyIT/understanding-erc-standards-a-guide-to-different-types-of-blockchain-tokens-e7991e4ecd61
    * https://www.blockchain-council.org/ethereum/erc20-vs-erc721/
    * https://medium.com/quick-programming/what-is-erc165-and-why-you-should-use-it-d0641a2f29e5
    * https://medium.com/@chiqing/ethereum-standard-erc165-explained-63b54ca0d273
    * https://ethereum.stackexchange.com/questions/83561/why-use-the-erc165-standard
    * https://eips.ethereum.org/EIPS/eip-165
    * https://docs.openzeppelin.com/contracts/
    * https://techjd.medium.com/what-is-supportsinterface-understanding-erc165-503b40b942a6
    * https://ethereum.stackexchange.com/questions/44880/erc-165-query-on-erc-721-implementation
    * https://www.quicknode.com/guides/ethereum-development/nfts/how-to-create-and-deploy-an-erc-1155-nft#:~:text=What%20is%20ERC1155%3F,were%20required%20to%20achieve%20this.
    * https://blog.thirdweb.com/what-is-erc-1155-nft/
    * https://docs.openzeppelin.com/contracts/5.x/erc1155
    * https://decrypt.co/resources/what-is-erc-1155-ethereums-flexible-token-standard
    * https://ethereum.org/en/developers/docs/standards/tokens/erc-1155/
    * https://www.linkedin.com/pulse/erc-1155-demystified-deep-dive-versatile-token-asset-mukul-tripathi/
    * https://moralis.io/erc-1155-nfts-what-is-the-erc-1155-standard/
    * https://limechain.tech/blog/erc-721-vs-erc-1155-ethereum-token-standards/
    * https://www.leewayhertz.com/erc-20-vs-erc-721-vs-erc-1155/
    * https://mightyblock.co/blog/news/how-to-build-and-use-erc-1155-tokens/
    * https://medium.com/@konradmgnat/what-is-the-erc1155-token-and-when-to-use-it-fc53b5d001ca
    * https://medium.com/codex/token-standards-erc-20-vs-erc-721-vs-erc-1155-2e4a09dc0f8a
    * https://medium.com/envienta-open-source-everything/erc-1155-non-fungible-tokens-on-steroids-71aab96fa674
    * https://pancy.medium.com/building-event-tickets-with-erc-1155-contract-1c427d89a77d
    * https://soenkeba.medium.com/truly-decentralized-nfts-by-erc-1155-b9be28db2aae
    * https://medium.com/@Consensys/an-introduction-to-ipfs-9bba4860abd0#:~:text=At%20its%20core%2C%20IPFS%20is,also%20a%20distributed%20file%20system.
    * https://whatdoesthequantsay.com/2015/09/13/ipfs-introduction-by-example/
    * https://medium.com/geekculture/what-is-ipfs-the-inter-planetary-file-system-explained-40744a7ae95a
    * https://medium.com/aleph-im/ipfs-explained-in-2min-24e10afdb191
    * https://medium.com/@sjarancio/ipfs-what-it-is-how-it-works-and-why-its-needed-49b75d8e857b
    * https://medium.com/virtuslab/the-complete-beginners-guide-to-ipfs-9713a6f59193
    * https://medium.com/@akshay_111meher/how-ipfs-works-545e1c890437
    * https://ipfs.io/ipfs/QmRU1jJ1kNd9fTzjFwM4X9YtA2wfXN1W2eFK7mgTMJ8xgK
    * https://medium.com/coinmonks/the-technology-behind-ipfs-and-what-can-ipfs-do-c7009fe42bab
    * https://itsromiljain.medium.com/ipfs-the-permanent-distributed-web-7a0d3ede10af
    * https://itsromiljain.medium.com/ipfs-the-permanent-distributed-web-continues-ffbe1919bb94
    * https://medium.com/pinata/what-is-an-ipfs-pinning-service-f6ed4cd7e475
    * https://medium.com/hackernoon/ipfs-and-merkle-forest-a6b7f15f3537
    * https://medium.com/hackernoon/a-beginners-guide-to-ipfs-20673fedd3f
    * https://medium.com/textileio/swapping-bits-and-distributing-hashes-on-the-decentralized-web-5da98a3507
    * https://medium.com/textileio/whats-really-happening-when-you-add-a-file-to-ipfs-ae3b8b5e4b0f
    * https://medium.com/textileio/how-ipfs-peer-nodes-identify-each-other-on-the-distributed-web-8b5b6476aa5e
    * https://medium.com/@Nico_Vergauwen/create-your-own-ethereum-token-part-2-erc223-3076f764cf62

## best practices
    * don't use plain secret on-chain
        * problem: front-running attacks
            * all the transaction data is open and can be seen by others
                * even data of pending transaction can be seen by others
            * example: domain name registration
                * user is registering a unique value
                * attacker watch for the transactions on that contract
                    * send the high gas-price transaction to front run the user's transaction
        * solution: commit-and-reveal scheme
            * hash of the original secret is submitted to the blockchain
            * steps
                1. all parties submit their secret hash
                1. all parties reveal their choice by submitting salt (that was used to generate the secret hash)
    * don't use `tx.origin` for authorization
        * problem: intercepting transaction
            1. we have `Vault` contract, that has function `withdraw()` using `tx.origin` for authorization
            1. attacker deploys AttackerContract
            1. attacker ask the original owner of the Vault contract to send some ether to the AttackerContract
            1. AttackerContract calls the Vault.withdraw() function
        * solution: always use `msg.sender`
    * avoid dependency on untrusted external calls
        * problems
            * if the target contract is killed via selfdestruct, the external call to the function will always fail
            * reentrancy attack
                * re-enter origin contract before the state changes are finalized
            * unpredictable gas costs
    * reentrancy attacks
        * problem: re-enter origin contract before the state changes are finalized
            * example (2016 dao hack)
                ```
                function withdraw(uint amount) public {
                     require(balanceOf[msg.sender] >= amount);
                     msg.sender.call{value: amount}(""); // invokes fallback function in caller, which in turns invokes withdraw again
                     balanceOf[msg.sender] -= amount;
                     Withdrawal(msg.sender, amount);
                }
                ```
        * solution: checks-effects-interactions (CEI) pattern
            * example
                ```
                function withdraw(uint amount) public {
                    // Checks phase
                    require(balanceOf[msg.sender] >= amount, "Insufficient balance");

                    // Effects phase
                    balanceOf[msg.sender] -= amount;

                    // Interactions phase
                    (bool success, ) = msg.sender.call{value: amount}("");
                    require(success, "Transfer failed");

                    // Emit event after successful interaction
                    emit Withdrawal(msg.sender, amount);
                }
                ```
    * replay attack
        * problem
            * cross-chain signature replay
                * example
                    ```
                    function deposit() public payable { // reply transaction from testnet on the mainnet
                        balances[msg.sender] += msg.value;
                    }
                    ```
                * usually happen during chain splits or hard forks
                    * Ethereum: signed transaction is valid for all Ethereum chains
                    * Bitcoin: addresses in testnet use a different prefix from addresses in mainnet
                        * keys are different
                * solution: use chainId when generating a signature
            * same-chain signature replay
                * example
                    ```
                    function deposit() public payable { // attacker rebroadcasts the same transaction with the same parameters
                        balances[msg.sender] += msg.value;
                    }
                    ```
                * solution: use nonce when generating a signature
        * solution
            * two approaches
                * strong replay protection
                    * one of the forked chains will make it mandatory to change some information in the transaction for it to be valid over its network
                * opt-in reply protection
                    * users must make manual changes to the transaction to ensure that they won’t be replayed
                    * example: Ethereum Classic (ETC) did not implement strong replay protection during the hard fork
            * EIP155
                * called "simple replay attack protection"
                * defines the chainID field in Ethereum transactions to prevent replay attacks
                * before EIP155
                    * there are 6 inputs to an Ethereum transaction
                        * nonce, gasPrice, gasLimit, to, value, data
                    * transaction is not chain specific
                        * same addresses in different networks => can lead to unintended transactions
                * user should sign the data along with a unique nonce value each time
                    * example
                        ```
                        mapping(address => uint256) public nonces;

                        function deposit(uint256 nonce) public payable {
                            require(nonce > nonces[msg.sender], "Invalid nonce");
                            nonces[msg.sender] = nonce;
                            balances[msg.sender] += msg.value;
                        }
                        ```
                * every transaction signature should also encapsulate a unique identifier for the specific network
            * EIP191
                * called "signature data standard"
                * introduces a prefix to the data that is being signed
                    * example
                        ```
                        "\x19Ethereum Signed Message:\n32"
                        ```
                        * byte `0x19` standardized because an already existing implementation (in the Go Ethereum client software)
                        was using it before the standard was finalized
                        * last number `32` is the byte length of the message (excluding the prefix)
                * reason for prefixing is so that a cleverly designed message cannot possibly be a valid transaction
                    * allowing signing raw messages, without a prefix, enables an app to steal all ether, tokens and assets
                        * purpose is entirely to invalidate any payload as a valid RLP encoded transaction
                        * MetaMask does not permit you to perform this operation
                            * it will always force prefixing a signed message even when the message is a hash
                    * when you create a transaction: unsigned transaction -> hash it -> sign it
                    * when you create a message: unsigned message -> prefix it -> hash it -> sign it
                    * example
                        ```
                        let unsignedTransaction = "0xe980850218711a00825208948ba1f109551bd432803012645ac136ddd64dba72880de0b6b3a764000080";
                        ```
                        decoded with https://flightwallet.github.io/decode-eth-tx/
                        ```
                        {
                          "nonce": 0,
                          "gasPrice": 9000000000,
                          "gasLimit": 21000,
                          "to": "0x8ba1f109551bd432803012645ac136ddd64dba72",
                          "value": 1000000000000000000,
                          "data": ""
                        }
                        ```
                        * if attacked gives you this hash and you sign it => it is now a valid signed transaction which will send 1 ether to attacker
                        * string that begins with "\x19Ethereum Signed Message:" is not a valid transaction
                            * it is safe to sign it
                * eliminates the risk of replay attacks on other EVM platforms
                    * if there were no platform-specific prefixes, the resulting signature would be the same for all platforms
                * use case
                    * smart contract needs to verify a signed message
                    * external systems need to interact with Ethereum transactions in a standardized way
                * list of chain ids: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md?ref=blog.hook.xyz#list-of-chain-ids
            * EIP712
                * is a more advanced and secure method of signing a transaction
                * provides a way to hash and sign typed structs rather than just strings
                    * uses the keccak256 hashing algorithm
                * requires TypedData (JSON object input)
                    * example
                        ```
                        typedData := apitypes.TypedData{
                        	Types:       types,
                        	PrimaryType: "ERC721Order",
                        	Domain:      domain,
                        	Message:     message,
                        }
                        ```
                    * includes the following properties
                        * types
                            * used to define the structs that will be used in the message and specify their types
                            * is a mapping of string to a Type array
                                * example
                                    ```
                                    types := apitypes.Types{
                                    	"EIP712Domain": {
                                    		{Name: "name", Type: "string"},
                                    		{Name: "version", Type: "string"},
                                    		{Name: "chainId", Type: "uint256"},
                                    		{Name: "verifyingContract", Type: "address"},
                                    	},
                                    	"ERC721Order": {
                                    		{Name: "direction", Type: "uint8"},
                                    		...
                                    	},
                                    	"Fee": { // custom types
                                        	{Name: "recipient", Type: "address"},
                                        	{Name: "amount", Type: "uint256"},
                                        	{Name: "feeData", Type: "bytes"},
                                        },
                                    ```
                        * domain
                            * information specific to the protocol contract that the dapp used when asking for a signature
                            * designed to include bits of DApp unique information
                                * name
                                    * human-readable string that represents the name of the domai
                                    * often used to identify the dApp or smart contract associated with the message
                                * version
                                    * string representing the version of the domain
                                    * can be useful for distinguishing between different versions of the same dApp or smart contract
                                * chainId
                                    * wallet providers should prevent signing if it does not match the network it is currently connected to
                                    * it is crucial that chainId is verified on-chain
                                        * contracts have no way to find out which chain ID they are on
                                            * developers must hardcode chainId into their contracts and take extra care to make sure that it corresponds to the network they deploy on
                                * verifyingContract
                                    * address of the smart contract that will verify the signed message
                            * domain separator
                                * information from the domain also needs to be hashed and used as a domain separator
                                * purpose is to disambiguate between two dapps with identical structures
                                    * in order to avoid generating the same signatures for both
                                    * example
                                        * two DApps come up with an identical structure like Transfer(address from,address to,uint256 amount)
                                        * with domain separator the dApp developers are guaranteed that there can be no signature collision
                        * primaryType
                            * string that represents the outermost type of the message object
                        * message
                            * contains the order element names as strings mapped to their values
                            * example
                                ```
                                {
                                    amount: 100,
                                    token: “0x….”,
                                    id: 15,
                                    bidder: {
                                        userId: 323,
                                        wallet: “0x….”
                                    }
                                }
                                ```
                                can be split into two data structures
                                ```
                                Bid: {
                                    amount: uint256,
                                    bidder: Identity
                                }
                                Identity: {
                                    userId: uint256,
                                    wallet: address
                                }
                                ```
                        * example
                            ```
                            domainSeparator, err := typedData.HashStruct("EIP712Domain", typedData.Domain.Map())
                            typedDataHash, err := typedData.HashStruct(typedData.PrimaryType, typedData.M
                            rawData := []byte(fmt.Sprintf("\x19\x01%s%s", string(domainSeparator), string(typedDataHash)))
                            hashBytes := keccak256(rawData)
                            hash := common.BytesToHash(hashBytes)
                            ```
                * standard for secure off-chain signature verification on the Ethereum blockchain
                * signature verification
                    * process of checking that the address of the signer is equal to the address that you derive from the signature
                        ![Alt Text](img/verifying_signature.png)
                    * ecrecover
                        * is vulnerable
                            * it interprets v values of both 27 and 28 as equivalent
                                * it only checks if v is greater than or equal to 27
                                * signatures produced with both v = 27 and v = 28 will yield the same public key
                            * it does not halt execution when invalid signatures are supplied
                                * it simply returns the address 0x0
                                    * zero address in most contracts has a special meaning (i.e. burn address)
                                    * smart contract might incorrectly assume that the zero address is a valid signer
                            * use: OpenZeppelin’s ECDSA library
                        * used to derive the address of a sender based on the digital signature
                        * needs assembly
                    * example
                        * replicate this formatting/hash function
                        ```
                        struct Identity {
                            uint256 userId;
                            address wallet;
                        }
                        struct Bid {
                            uint256 amount;
                            Identity bidder;
                        }

                        string private constant IDENTITY_TYPE = "Identity(uint256 userId,address wallet)";
                        string private constant BID_TYPE = "Bid(uint256 amount,Identity bidder)Identity(uint256 userId,address wallet)";

                        uint256 constant chainId = 1;
                        address constant verifyingContract = 0x1C56346CD2A2Bf3202F771f50d3D14a367B48070;
                        bytes32 constant salt = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558;
                        string private constant EIP712_DOMAIN = "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)";
                        bytes32 private constant DOMAIN_SEPARATOR = keccak256(abi.encode(
                            EIP712_DOMAIN_TYPEHASH,
                            keccak256("My amazing dApp"),
                            keccak256("2"),
                            chainId,
                            verifyingContract,
                        ));

                        function hashIdentity(Identity identity) private pure returns (bytes32) {
                            return keccak256(abi.encode(
                                IDENTITY_TYPEHASH,
                                identity.userId,
                                identity.wallet
                            ));
                        }
                        function hashBid(Bid memory bid) private pure returns (bytes32){
                            return keccak256(abi.encodePacked(
                                "\\x19\\x01",
                               DOMAIN_SEPARATOR,
                               keccak256(abi.encode(
                                    BID_TYPEHASH,
                                    bid.amount,
                                    hashIdentity(bid.bidder)
                                ))
                            ));

                        function verify(address signer, Bid memory bid, sigR, sigS, sigV) public pure returns (bool) {
                            return signer == ecrecover(hashBid(bid), sigV, sigR, sigS);
                        }
                        ```
                * wallets like Metamask can display the message in a more user-friendly manner
                    * the signer can actually check the data before signing
                        * display in a human-readable way that users can understand and review before signing
                    * example
                        ![Alt Text](img/eip721_metamask.png)
                * before EIP712
                    * it was difficult for users to verify the data they were asked to sign
                    * wallet signing interfaces would display a hashed message string
                        * the signer would have to assume that hash matched the message they thought they were signing
                * use case
                    * meta-transactions
                        * relayer pays the gas fees on behalf of the user
                            * relayer = service responsible for submitting transactions on behalf of users
                        * users sign a request (off-chain) for a specific action they want to perform on the blockchain
                            * includes information like the target contract, function to call, and any required parameters
    * short address attack
        * equivalent of minor SQL injection bug
        * problem: leading zeros is taken from the amount, and given to the shortened address
            * * means you've multiplied your amount by 1<<8 or 256
                * after the exchange has checked your balance on their internal ledger
            * reason: EVM pads all input data with 0s
            * example
                1. user B's address: 0xbbbbbb00
                1. user A's balance: 512 tokens
                1. A inputs B's address as 0xbbbbbb
                1. site (incorrectly) interprets this as a valid address and constructs transaction
                    * selector: 0x01020304
                    * transaction: 0x01020304bbbbbbbb00000001
                1. if we slice that back up into a 4-byte signature and 2 4-byte words
                    * ['0x01020304', '0xbbbbbb00', '0x000001??']
                1. any index into the transaction data that hasn't been provided returns 0s
                    * trailing zeros do not change the actual address
                        * `0x1234...5670` and `0x1234...567000` represent the same address
                1. final argument being interpreted by the EVM as 0x00000100 = 256
                    * 256
                1. given that 256 is still less than 512 (your comment), the transaction succeeds
            * most vulnerable to this were large, shared wallets
                * example: exchange hot wallets
        * solution: smart contract must validate the length of an address input
    * manipulating contract balance
        * problem: ether can be sent forcibly to a contract
            * if contract has some decision logic using `address(this).balance` - attacked can influence it
            * example
                ```
                selfdestruct(addressOfAttackedContract)
                ```
        * solution: there is no possible way to prevent forceful ether sending from happening
    * Ethernaut game
        * Web3/Solidity based war game created by OpenZeppelin
        * each level is a smart contract that needs to be ‘hacked’
        * solutions: https://stermi.medium.com/lets-play-ethernaut-ctf-learning-solidity-security-while-playing-1678bd6db3c4

## design patterns
    * security
        * pull-over-push (withdrawal pattern)
            * example of the problem
                ```
                for(uint i = 0; i < users.length; i++) { users[i].transfer(amount); };”
                ```
                * if some address is a contract it may have continually failing fallback function
                    * leads to whole transaction failure each time
            * solution: user should be able to claim their dividend from the contract
            * use cases
                * send ether/token to multiple addresses
                * avoid paying transaction fees (push transaction)
                    * transaction initiator has to pay the transaction fee
                    * users pay transaction fees (pull transaction)
        * access restriction
            * restricts unauthorized function calls
            * based on roles
            * use modifiers to check for the access rights
        * emergency stop
            * ability to pause the contract functions in unwanted situations
            * use cases
                * contract to be handled differently in case of any emergency situations
    * creational patterns
        * factory
            * create a new child contract from a parent contract
            * https://eips.ethereum.org/EIPS/eip-1167
            * example
                * master contract can create a new child contract called Loan
                    * Loan contract has logic to handle contract terms and conditions along with the funds as well
            * use case
                * new contract is required for each request to be processed
                * keep the funds separate in a different contract
    * behavioral patterns
        * state machine
            * allows a contract to transition from different states
            * enables certain functions to be executed in each state
            * use cases
                * contract needs to have different set of functions based on the state
        * iterable map pattern
            * example
                ```
                mapping(uint256 => uint256) private data;
                uint256[] private keys;

                function removeValue(uint256 key) external {
                    require(data[key] != 0, "Key does not exist");
                    for (uint256 i = 0; i < keys.length; i++) {
                        if (keys[i] == key) {
                            // Swap the element to be removed with the last element
                            keys[i] = keys[keys.length - 1];
                            // Shorten the keys array by one
                            keys.pop();
                            break;
                        }
                    }
                    delete data[key];
                }
                ```
            * allows to iterate over the mapping entries
            * iteration over the mapping entries should not cause an out-of-gas exception
            * iteration should be used only in the view function
            * does not support removal of elements
            * use cases
                * need to filter some data out of the mapping
        * whitelisted addresses
            * maintain a curated list of addresses by the owner
            * use cases
                * whitelisted address allowed/disallowed to perform a certain task
    * gas-optimization
        * worth to check: https://github.com/mtumilowicz/ethereum-gas-workshop
        * keccak256 for equality check
            * example: string equality
            * use case
                * gas-optimized solution for equality
        * variable packing
            * minimize slots used by storage
            * each storage slot is 32 bytes
            * use case
                * gas-optimized solution for storage
    * life cycle
        * “Once a contract is destroyed, it cannot be recreated on the same address. ”
        * mortal pattern allows a contract to be destroyed from the Ethereum blockchain.”
            * “The mortal pattern should be used in the following cases, when:
                * You do not want a contract to be present on the blockchain once its job is finished
                * You want the ether held on the contract to be sent to the owner and the contract is not required further
                * You do not need the contract state data after the contract reaches a specific state”
        * auto deprecate
            * allows time-based access to certain function calls
            * example (using chainLink oracle)
                ```
                modifier onlyPremium() {
                    require(subscriptionExpiry[msg.sender] >= getCurrentTime(), "Must be a premium member");
                    _;
                }

                function getCurrentTime() internal returns (uint256) {
                    Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
                    req.add("get", "https://chain.link/v1/time");
                    req.add("path", "now");

                    return sendChainlinkRequestTo(oracle, req, fee);
                }
                ```
            * use cases
                * allow/restrict a function call for a specified duration of time
                * auto-expired contract
                * periodic paid service-based model
                * existing user can purchase a premium status for a limited duration

## ipfs
* stands for Interplanetary File System
    1. suppose humanity has colonises Mars and the first person on Mars tries to access internet services from Earth
    1. it would approximately take 1 hour for him to access a news website
    1. what if another person tries?
        * he ends up taking another 1 hour and so on
        * but IFPS is used, the second person on Mars shall be able to retrieve the content from the first person
            * from there onwards data can spread like a wildfire
* three main principles
    1. unique identification via content addressing
        * means that the content is going to determine the address
            * once something is added it can’t be changed
        * intuitive way to think about content for humans
            * example: ask someone for their favorite cat video
                * location answer: "the one on this server, at this sub-domain, under this file path, slash hilarious dash cat dot mp4"
                * description answer: "the one where the cat knocks the glass off the counter"
            * is generally not how we access content on the web today
                * http
                    * refers objects (text files, pics, videos) by which server they are stored on
                        * called "location based addressing"
                            * location is the IP address or the domain name
                            * if location isn’t accessible (the server is down), you won’t get resources
                                * there is a high probability that someone else out there has downloaded resource and still has a copy of it
                                    * yet your computer won’t be able to grab it from that other person
                        * IPFS moves from "location based addressing" to "content based addressing"
                            * instead of creating an identifier that addresses things by location
                                * address it by some representation of the content itself
                            * if in your browser you want to access a particular page then IPFS will ask the entire network "does anyone have this file that corresponds to this hash?"
                                * instead of saying where to find a resource, you just say what it is you want
                    * is great for loading websites but it wasn’t designed for the transfer of large amounts data
                        * example: audio, video files
                        * files are downloaded from one server at a time
                            * IPFS retrieves pieces of files from multiple nodes at once
                                * enables bandwidth savings of up to 60% for things like videos
                        * enabled the emergence and mainstream success of alternative filesharing systems
                            * example: Napster (music) and BitTorrent (movies and pretty much anything)
        * mechanism
            * overview
                ![Alt Text](img/cid_creation.png)
            1. take a file
            1. hash it cryptographically
                * very small and secure representation of the file
                * hashes are actually something called a multihash
                    * specifies which hash function it used
                    * specifies the length of the resultant hash in the first two bytes of the multihash
                    * example: hashes all seem to start with Qm
                        * 12 denotes that this is the SHA256
                        * output length is 20 in hex (or 32 bytes)
                        * we get the Qm from when we base58 encode the whole thing
        * address usually starts with a hash that identifies some root object and then a path walking down
            * instead of a server, you are talking to a specific object and then you are looking at a path within that object
    1. content is linked via Merkle Directed Acyclic Graphs (DAGs)
        * hashes are used to reference data blocks and objects in a DAG
        * similar to Merkle tree
            * difference: Merkle DAG non-leaf nodes are allowed to contain data
        * need not be balanced
        * example: https://explore.ipld.io/#/explore/QmWNj1pTSjbauDHpdyg5HQ26vYcNWnubg1JehmwAE9NnU9
        * de-duplication by design
            * we reference content (not the files themselves)
            * adding a new file to the network will take less storage as the network gets larger
                * assuming the file is relatively similar to others in the network
    1. content discovery system is facilitated via Distributed Hash Tables (DHTs)
        * information about which node stores what blocks is organized as a distributed hash table
            * split across the nodes just like data itself
        * small values (equal to or less than 1KB) are stored directly on the DHT
        * for larger values, the DHT stores references (NodeIds of peers who can serve the block)
        * ask the network = query the distributed hash table
        * based on Kademlia
            * pretty common is p2p systems
        * example: find peers that can provide a particular bit of content
            ```
            ipfs dht findprovs QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ
            ```
* distributed file system that seeks to connect all computing devices with the same system of files
    * small file (< 256 kB)
        * represented by an IPFS object
            * data = the file contents (plus a small header and footer)
            * no links, i.e. the links array is empty
    * large file (> 256 kB)
        * represented by an IPFS object
            * data = specifying that this object represents a large file
            * links = list of links to file chunks that are < 256 kB
    * directory is represented by a list of links to IPFS objects representing files or other directories
        * example: assume that all three files with an asterisk (*) contain the same text: “Hello World!/n”
            ```
            test_dir/
            ├── bigfile.js
            ├── *hello.txt // "Hello World!/n"
            └── my_dir
                ├── *my_file.txt // "Hello World!/n"
                └── *testing.txt // "Hello World!/n"
            ```
            DAG
            ![Alt Text](img/dag_directory.png)
    * IPFS object
        * example
            ```
            $ ipfs object get QmarHSr9aSNaPSR6G9KFPbuLV9aEqJfTk1y9B8pdwqK4Rq // normally referred to by their Base58 encoded hash
            {
              "Links": [
                {
                  "Name": "AnotherName",
                  "Hash": "QmVtYjNij3KeyGmcgg7yVXWskLaBtov3UYL9pgcGK3MCWu",
                  "Size": 18
                },
                {
                  "Name": "SomeName",
                  "Hash": "QmbUSy8HCn8J4TMDRRdxCbK2uCCtkQyZtY6XYv3y7kLgDC",
                  "Size": 58
                }
              ],
              "Data": "Hello World!"
            }
            ```
        * Data - a blob of unstructured binary data of size < 256 kB
        * Links - an array of Link structures (links to other IPFS objects)
            * Name — the name of the Link
            * Hash — the hash of the linked IPFS object
            * Size — the cumulative size of the linked IPFS object, including following its links
        * note that the file name is not part of the IPFS object
            * two files with different names and the same content => same IPFS object representation
                * and hence the same hash
* is essentially a P2P system for retrieving and sharing IPFS objects
* acts as a decentralized source of data
    * distributed: processing is shared across multiple nodes
        * decisions may still be centralized and use complete system knowledge
    * decentralized: no single point where the decision is made
        * every node makes a decision for it’s own behaviour
        * resulting system behaviour is the aggregate response
* self-certifying file system
    * peer node can perform authentication and encryption
        * when you initialize a new peer IPFS generates a pair of keys for it (private and public)
            ```
            $ ipfs init
            initializing IPFS node at ~/.ipfs/
            generating 2048-bit RSA keypair...done
            peer identity: Qm...
            ```
    * peers are identifying each other via their peer ID
        * is essentially a cryptographic hash of it’s public key
        * enables peers to find each other and authenticate themselves once they get connected
    * when two peers connect to each other they exchange public keys
        * connections between peers are encrypted and authenticated by default
        * authenticity of this data can be verified using the sender’s public key
* operations
    * retrieving
        * when a node retrieves data from the network it keeps a local cache of that data for future usage
            * nodes frequently clear this cache out in order to make room for new content
        * HTTP -> IPFS gateway
            * we can access any one of our files from their website
            * https://ipfs.github.io/public-gateway-checker/
            * example
                * https://ipfs.io/ipfs/[yourHash]
                * https://ipfs.io/ipfs/QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u
                * https://gateway.ipfs.io/ipfs/QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u
        * anyone can access your data provided that they know the hash
            * use combination of symmetric and asymmetric encryption
        * retrieving files from peer nodes and not some trusted centralized server
        * trust: how can you be sure that the file you requested hasn’t been tampered with?
            * since we are using a hash to request the file, you can verify what you received
            * upon receiving a file, you can check if the hash of the file received matches the hash of the file requested
                * any change to the file itself will change the hashed address
    * adding
        * each node chooses which file to store
            * long-term IPFS storage: Filecoin
    * pinning
        * act of saving data on a node
        * prevents important data from being deleted from your node when the clearing process happens
        * you can only control and pin data on your node(s)
            * cannot force other nodes on the IPFS network to pin your content for you
            * to guarantee your content stays pinned, you have to run your own IPFS nodes
        * by pinning the file, other nodes on the network know they can access the file
* is similar to a single BitTorrent swarm exchanging git objects
    * IPFS = one big swarm of peers for all data
        * difference: in BitTorrent each file has a separate swarm of peers (forming a P2P network with each other)
    * BitTorrent
        * is a successful and widely implemented protocol used to share large data files in a distributed manner
            * example: digital video sharing (TV shows, movies, video clips, etc)
        * splits large data files into segments
            * distributed over different nodes of a peer-to-peer network
            * result: data is being shared from more than one source
                * we are not exhausting a single server
* BitSwap
    * their own exchange protocol
    * data trading module for IPFS
    * two primary jobs
        1. attempt to acquire blocks from the network that have been requested by the client peer (your local peer)
        1. judiciously (though strategically) send blocks of data that it already has in its possession to other peers who want those blocks
    * example
        1. verify that wantlist is empty (we aren’t in the middle of requesting anything)
            ```
            ipfs bitswap wantlist
            ```
        1. get a large file from the network
            ```
            ipfs get QmdpAidwAsBGptFB3b6A9Pyi5coEbgjHrL3K2Qrsutmj9K // Big Buck Bunny video
            ```
        1. query wantlist again
            ```
            ipfs bitswap wantlist // multiple hashes that are being requested from the network
            ```
* consensus algorithm: Raft
    * peers coordinate their state
        * example: the list of CIDs which are pinned, their peer allocations and replication factor
    * is used to commit log entries to a "distributed log" which every peer follows
        * example: every "Pin" and "Unpin" requests are log entries in that log
            * when a peer receives a log "Pin" operation, it updates its local copy of the shared state
                * indicates that the CID is now pinned
    * Leader
        * election can only succeed if at least half of the nodes are online
        * only peer allowed to commit entries to the log
        * required for other parts of ipfs-cluster functionality (initialization, monitoring)
* blockchain
    * problem: on the Ethereum platform you pay a rather large fee for storing data in the associated state database
        * minimizes bloat of the state database ("blockchain bloat")
        * solution: store not the data itself but hash of the data
            * distinction between storing a hash on the blockchain and storing the data on the blockchain becomes somewhat blurred
            * example: store an IPFS link in the blockchain
                * we can seamlessly follow this link to access the data as if the data was stored in the blockchain itself
    * problem: centralized nft
        * returns the metadata location in the form of: `HTTP://centralizedserver.com/TokenID`
            * here is nothing stopping the image host from changing the image which the URL points to
        * solution: IPFS
            * problem: cannot set `ipfs://contendidentifierhash/TokenID`
                * IPFS can only provide an immutable hierarchical file system structure
                * requirement: all tokens and TokenIDs are set at the time of the smart contract deployment
                * solution: TokenID as a pointer itself to the metadata
                    * `TokenID=IPFScontentidentifierhash`
                    * idea by Titusz Pan
                    * we would then just add "ipfs://" in front
                    * example
                        ```
                        $ ipfs add MetaDataIPFSToken.json cid-version=1 hash=blake2b-208
                        added bafkzvzacdkm3bu3t266ivacqjowxqi3hvpqsyijxhsb23rv7nj7a MetaDataIPFSToken.json
                        ```
                        then convert it to hex “-b=base16”
                        ```
                        $ ipfs cid format -b=base16 bafkzvzacdkm3bu3t266ivacqjowxqi3hvpqsyijxhsb23rv7nj7a
                        f01559ae4021a99b0d373d7bc8a80504bad782367abe12c21373c83adc6bf6a7e
                        ```
                        without f0 gives a token ID
                        ```
                        constructor() public ERC1155("ipfs://f0{id}") { // "f0" is not part of the CID, but rather a representation of the format being used (base16)
                        ```

## tokens
* any asset that is digitally transferable between two people
* smart contract representing digital assets
    * simple "databases" on the blockchain
        * example
            * ERC20: stores balances of Ethereum addresses
            * ERC721: unique ID -> Ethereum address assignments
* types
    * fungible asset
        * means that the individual units of an asset are interchangeable and essentially indistinguishable from one another
        * example: currency
            * $50 is always $50
    * non-fungible asset
        * means that the individual units of an asset are distinct and unique
            * often possessing specific attributes, characteristics, or properties that set them apart from one another
            * cannot be exchanged on a one-to-one basis
        * example: education and certification
            * Einstein diploma is not the same as Oppenheimer diploma
* history
    * coin is a digital asset which is native to its blockchain
    * Bitcoin established the paradigm for other crypto projects: in order to issue any digital currency, a separate blockchain must be launched
        * rule has been broken by Ethereum: smart contacts enabled to create a token and assign it unique useful functions within your own application
    * ability for any developer to release their digital asset without the need for a separate blockchain has become a turning point in the history of cryptocurrencies
* problem: supporting an increasing number of tokens became increasingly difficult
    * in order for the exchange or wallet to support the token, the creators had to write new code each time
    * example: prior to ERC-20,there was a problem with token compatibility because each of them had a unique smart contract
    * solution: standard protocol for all tokens (ERC)
        * play a pivotal role in ensuring interoperability and compatibility among different smart contracts and decentralized applications (DApps)
        * ERCs are analogous to RFCs
        * Ethereum Improvement Proposals (EIPs): focused on the Ethereum protocol
* decentralization
    * nearly half of the top 20 projects can have their token transfers completely frozen by an owner (a single key or a multisig contract)
        * pausing can be valuable for future upgrades, swaps, and disaster mitigation but also leads to new risks

## erc20
* example: Tether (USDT)
    * value is pegged to the US dollar at a 1:1 ratio
    * commonly used to move funds between exchanges quickly and easily
* use cases
    * reputation points of any online platform
    * lottery tickets and schemes
    * financial assets such as shares, dividends, and stocks of a company
    * fiat currencies, including USD
    * gold ounce
* funglible
* six functions, two events, and three information
    * functions
        1. totalSupply - returns the total supply of tokens that have been created for a particular project
            * problem: Solidity and the Ethereum Virtual Machine do not support decimals: only integer numbers can be used
                * solution: use larger integer values (the EVM supports 256-bit integers)
                    * example: total supply 1000 tokens, with 18 decimal places (like Ethereum) = 1000*10**18
                        ```
                        _mint(msg.sender, 1000 * 10**18); // mining 1000 tokens
                        transfer(recipient, 2 * 10**18); // sending 2 tokens
                        ```
        1. balanceOf - returns the balance of tokens held by a particular address
        1. transfer - allows an address to send tokens to another address
            * the only transaction that happens on the blockchain is the contract call
            * transferring tokens from one account to another = simply update internal variable “_balances”
            * problem: Solidity and the Ethereum Virtual Machine do not support decimals: only integer numbers can be used
                * solution: token contract can use larger integer values (the EVM supports 256-bit integers)
                    * example: 1000000000000000000 represents 1 ETH (with 18 decimal places)
                        * transfer of 4000000000000000 will correspond to 0.004ETH being sent
                    *
            * token transfers are received at the contract silently
                * smart contract does not explicitly notify or acknowledge the receipt of tokens
                * solutions
                    1. ERC223 standard provides `tokenFallback` method that will be called once the tokens are transferred
                        ```
                        function transfer(address to, uint value, bytes data) {
                                uint codeLength;
                                assembly {
                                    codeLength := extcodesize(_to) // user wallets do not have code associated with them
                                }
                                balances[msg.sender] = balances[msg.sender].sub(_value);
                                balances[_to] = balances[_to].add(_value);
                                if(codeLength>0) {
                                    // Require proper transaction handling.
                                    ERC223Receiver receiver = ERC223Receiver(_to);
                                    receiver.tokenFallback(msg.sender, _value, _data);
                                }
                            }
                        ```
                    1. approve plus transferFrom mechanism
                        * example
                            ```
                            contract DEX {
                                Erc20 public token;

                                constructor(address _tokenAddress) {
                                    token = Erc20(_tokenAddress);
                                }

                                function tradeTokens(address _buyer, uint256 _amount) external {
                                    // Assume _amount is the number of tokens the buyer wants to purchase
                                    require(token.transferFrom(_buyer, address(this), _amount), "Token transfer failed");
                                    // DEX now holds _amount of tokens

                                    // Perform trading logic here
                                    // ...
                                }
                            }
                            ```
        1. approve - allows an address to approve another address to spend tokens on their behalf
            * used by decentralized exchanges
            * front-running approval attack
                * problem: you change your approve amount to a given contract
                    * example: reduce the amount approved from 1 ETH to 0.5 ETH
                        * approved contract can race to transfer the money you initially approved (the 1 ETH)
                            * and then also spend the money you just approved (0.5 ETH)
                * solutions
                    1. use the increaseApproval() or decreaseApproval() functions
                    1. ensures that, before updating the value, it should be set to zero
                        ```
                        require(_value == 0 || allowed[msg.sender][_spender] == 0);
                        ```
        1. transferFrom - allows an address to transfer tokens from another address that has approved them to do so
            * prerequisite: approver must have called the approve() function prior
            * if called from within a Solidity contract recommended to enclose with require
                ```
                require(ERC20.transferFrom(from, to, value)) // in case of any transfer failure, the transaction should revert
                ```
        1. allowance - returns the amount of tokens that an approved address can spend on behalf of another address
        * developers can also add additional functions and features
            * example: OpenZeppelin implementation of ERC20 contracts
                * more functions such as _mint(), _burn(), and _burnFrom()
    * information
        1. name - returns the name of the token
        1. symbol - returns the symbol of the token
            * usually a few letters or characters that represent the token
        1. decimals - returns the number of decimal places that the token can be divided into
            * example: a token with 18 decimal places can be divided into 10^18 units
    * event
        * transfer(address indexed _from, address indexed _to, uint256 _value)
            * triggered whenever tokens are transferred
            * minting emits transfer event with the 0 address as the source
        * approval(address indexed _owner, address indexed _spender, uint256 _value)
            * triggered on any call to approve() function
* erc721
    * Let’s understand what can ERC-721 represents:
      - A unique digital content piece.
      - Real estate property.
      - Social media content Tweets, Videos, and pictures.
      - Gaming assets and collectibles.
      - Gaming characters.
    * Under ERC-721, each NFT also has a numerical identifier (uint256) called TokenID. Each contract address-TokenID pair must be unique. This practically ensures that NFTs remain unique even if they come from the same smart contract. It’s also how NFT collections can be created – the entire collection comes from a single ERC-721 contract, with each item having its own TokenID.
    * An ERC721 token represents a class of assets, whereas an ERC20 token represents a particular type of asset.
    * For example, a domain name is a non-fungible asset because there cannot be another domain name of the same sort due to its unique aspects. Thus, non-fungible tokens represent a single, unique and indivisible entity, whether physical or immaterial, such as intellectual property or photograph.
    * Through royalty implementations in the smart contract, original creators can receive a predetermined percentage of sales whenever the NFT changes hands.
    * Core Functionalities of an NFT Smart Contract
        * Minting NFTs
            * it creates a fresh, unique token within the contract
            * Minting can be restricted to certain addresses to prevent unauthorized creation of tokens.
        * Transferring NFTs
            * Approving: This grants permission for another address to transfer an NFT on behalf of the owner.
            * Safe Transfers: These functions ensure the destination address can handle the NFT, preventing accidental loss.
        * Burning NFTs
            * Burning removes an NFT from existence, reducing the total supply
        * Accessing NFT Metadata
            * The URI (Uniform Resource Identifier) function in a smart contract points to this metadata, allowing platforms and wallets to display the NFT’s distinct attributes.
        * example: https://example.com/nft/1
            ```
            {
              "name": "One Ring to Rule Them All",
              "description": "The One Ring, forged in the fires of Mount Doom, grants immense power to its bearer.",
              "image": "https://example.com/one_ring.jpg",
              "attributes": [
                {
                  "trait_type": "Type",
                  "value": "Artifact"
                },
                {
                  "trait_type": "Rarity",
                  "value": "Legendary"
                },
                {
                  "trait_type": "Power",
                  "value": "Dominion over all other rings"
                },
                {
                  "trait_type": "Owner",
                  "value": "Sauron"
                }
              ],
              "external_url": "https://example.com/one_ring",
              "franchise": "The Lord of the Rings",
              "lore": "Forged by the Dark Lord Sauron to control the other Rings of Power, the One Ring is a malevolent artifact of great evil."
            }

            ```
    * At the heart of NFTs lies smart contract development
    * Smart contracts play a critical role in the development and transfer of NFTs.
        * In the context of NFTs, smart contracts define the ownership and transfer rights of a particular digital asset, and they ensure that these rights are upheld throughout the lifetime of the asset.
    * Until the invention of the blockchain, most digital items couldn’t be non-fungible. Anybody could copy/save digital items (pictures, music, artwork) and you had no way of deciphering which one was the original or who owned what.
    * An NFT is a digital receipt of something you purchased
    * This uniqueness is defined by 4 main characteristics:
        * The sole creator
            * When the NFT is created, the creator will come and “sign” it
            * Indeed, by interacting with a “smart contract” (contract on a blockchain) the creator will initiate an event on a blockchain, which will allow time stamping and creating the NFT in an unalterable way.
            * To give you a more meaningful image of this signature via the blockchain, you can think of it as the equivalent of a painter’s signature on a canvas.
        * The unalterable identifier
            * The equivalent of the NFT’s identity card number is its identifier.
            * It is this sequence of numbers or letters, unmodifiable and unalterable, that will identify an NFT on a blockchain.
            * To draw a parallel with the physical world, this corresponds to a unique serial number.
        * Its content
            * Identifier and content of the NFT are two distinct elements
                * The identifier is defined at creation and is unalterable, which is what will be certain of the “identity” of the NFT
                * The content is also defined during creation but it can be totally or partially modified.
        * The current owner
            * Indeed, the last owner of the NFT will be known through the transfer between two blockchain wallets
            * It is thus possible to know all the owners in chronological order by using time-stamped blockchain transfers.
    * NFT is a type of digital token or asset
    * When you buy an NFT, you are buying a piece of data that points to a server that hosts that image.
        * So, what you own, is not the access to the server, and not the image itself, but rather that tiny piece of data that points to the server.
    * NFT stands for non-fungible token
        * the term ‘non-fungible’ denotes non-exchangeable, i.e. fully unique
        * a $100 dollar bill, which is a fungible asset since anybody may exchange their $100 bill for another $100 bill without issue
        * There have been reports of $1 notes with extremely uncommon serial numbers being traded for thousands of dollars.
        * For example, money is fungible, diamonds aren’t
            * Diamonds aren’t interchangeable as they all have different cuts, colours and sizes
            * You can’t swap one diamond for another because they won’t be guaranteed to hold the same value.
    * NFTs are digital assets that represent ownership or proof of authenticity of a unique item or piece of content, such as artwork, music, videos, or virtual real estate
    * NFTs are essentially digital certificates of authenticity
        * used to prove ownership of digital data, or to label anything in the digital world as your own.
    * example: a work of art, such as a painting
    * use cases
        * Art
            * most highly publicized examples of NFTs have been in visual art, especially videos and still images that have sold for millions of dollars
        * Collectibles
            * NFT technology has also proved a fit for digital versions of other collectibles, such as trading cards
            * Sports leagues including the NFL, MLB and NBA have all created digital collections memorializing things such as notable statistics and outstanding plays.
        * Gaming and virtual reality
            * NFTs can be attached to some unique video game items such as weapons, outfits or special characters — many of which have long been sold and traded in in-game marketplaces
            * when their digital assets can be transferred between games or platforms, or traded on open markets, they will invest more of their hard-earned cash
        * Licenses and Certifications
            * NFT use cases can also provide significant benefits for licensing and certification verification
            * Course completion certificates, like any other diploma or license, are typically offered to successful applicants in digital or paper form
            * Universities and employers require replicas of the course completion document as references before offering a position to someone in a company or institute.
    * Where to buy NFTs
        * OpenSea
            * Refers to itself as the “amazon of NFTs”, this marketplace has a large and wide variety of different types of NFTs consumers may want to investigate.
    * NFTs and blockchain ledgers give content creators and artists an opportunity to monetize their projects without the physical resources needed to do that in the real world.
        * For example, artists don’t have to rely on gallery shows or live auctions to be able to sell their art.
    * with NFTs, “copies” are worthless because they aren’t the original, and anybody can verify that
    * It was not possible to authenticate a digital ‘asset’ prior to the advent of NFT technology on a blockchain
    * Apart from being identifiable, NFTs carry other unique characteristics such as being indivisible, tradeable, fraud proof, scarce, and programmable.
        * NFT creators can specify that royalties be paid to them whenever an NFT changes hands
    * “ERC721 is a Non-Fungible Token (NFT) standard”
      * “This standard is used in many cases where you want to transfer a whole item that cannot be broken into multiple parts, for example, a house deed or collectible cards”
      * “As you can see in the code, the ERC721 interface also inherits from the ERC165 standard.”
      * “The ERC165 standard is known as the Standard Interface Detection, using which we can publish and detect all interfaces a smart contract implements”
      * In the OpenZeppelin implementation of the ERC721 standard, there are two approval mechanisms: tokenApprovals and operatorApprovals
        * tokenApprovals:
          * mapping(uint256 => address) internal _tokenApprovals;
          * This is a mapping from a token ID to an approved address.
          * It allows a specific address to transfer the ownership of a specific token.
          * It is used for one-time approvals and is cleared after the transfer is completed.
        * operatorApprovals
          * mapping(address => mapping(address => bool)) internal _operatorApprovals;
          * This is a mapping from an owner address to an operator address to a boolean value.
          * It allows an operator to manage (transfer or perform other operations) any tokens owned by the approved owner.
          * This approval is persistent until explicitly revoked.
      * “The transferFrom() function is a public function, used to transfer the given tokenId from the owner's account to the receiver's account. For this function to work, the approval must have been given previously by the owner to the address of the caller of this function.
        * “require(_isApprovedOrOwner(msg.sender, tokenId));”
      * “The safeTransferFrom() function is a public function that is used to safely transfer the NFT from the owner's account to the recipient account.”
        * “safely transfer means that, when a recipient is a contract, you need to ensure that the recipient contract has callbacks registered to let the receiver contract get a notification when ERC721 token transfer is successful”
        * “require(_checkOnERC721Received(from, to, tokenId, _data))”
        * “it makes a call to the _checkOnERC721Received() internal function, which further calls the “callback functions (the onERC721Received() function on the contract receiving the token) in case the recipient of the NFT is a contract (not an Externally Owned Account (EOA)).”
        * “You can pass on the function bytes data into the safeTransferFrom() function in the _data argument”
          * “When this _data parameter is not empty, the further function call will be initiated from the receiver's onERC721Received() function”
      * “contract ABC is ERC721, ERC721Enumerable, ERC721Metadata”
* erc1155
    * Technically, we called it the fungible-agnostic standard because the interface can handle both fungible and non-fungible tokens in a single contract “natively” without any kind of hack
        * Fungible-agnostic means the quality to be both fungible (breakable into small units and thus interchangeable) and non-fungible (atomic, non-breakable a.k.a NFTs)
    * As NFT can represent real estates, an ERC-1155 “sub-token” can represent business shares in a company.
        * Everyone own an equivalent amount of tokens as her or his share percentage in the company.
    * In order to set a different URI for each token, you would want to use the ERC1155URIStorage extension. For example, if each NFT is pinned to its own IPFS hash, with a unique base URL, then you would need to set the URI for each token individually using the _setURI() function.
        * _setURI(uint256 tokenId, string tokenURI)
        * The base ERC1155 implementation only has the ability to set the base URI in the constructor.
        * When the uri() function is called it returns the string that relies on the token type ID substitution mechanism.
            * his standard expects to return the string URI like https://token-cdn-domain/{id}.json with the token id replaced by its hexadecimal value padded with 64 zeros.
    * To achieve this, ERC-1155 makes use of TokenID, just like ERC-721, but there is one key difference. In ERC-1155 contracts each unique identifier represents a configurable token type that can have its own attributes, like supply, metadata and so on. If the supply is set at one, that token is treated as an NFT.
    * it allows users to create new items without having to deploy new contracts, which is utilized by many NFT marketplaces
    * ERC-1155 supports secure atomic swaps, allowing the exchange of two tokens within a single transaction.
    * FUNCTIONS AND FEATURES:
      Batch Transfer: Transfer multiple assets in a single call.
      Batch Balance: Get the balances of multiple assets in a single call.
      Batch Approval: Approve all tokens to an address.
        * This is intentionally designed with simplicity in mind. You can only approve everything for one address.
      Hooks: Receive tokens hook.
        * onERC1155BatchReceived
        * Given the EIP-165(opens in a new tab) support, ERC-1155 supports receive hooks for smart contracts only.
        * ERC-1155 supports receive hooks only for smart contracts. The hook function must have to return a predefined magic bytes4 value which is as following:
          bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))
          As soon as receiving contracts returns this value, we assume that the contract can now accept the transfer and it understand how to manage ERC-1155 tokens. That’s done!
        * When the receiving contract returns this value, it is assumed the contract accepts the transfer and knows how to handle the ERC-1155 tokens. Great, no more stuck tokens in a contract!
      NFT Support: If supply is only 1, treat it as NFT.
      Safe Transfer Rules: Set of rules for secure transfer.
        * The transfer call must revert if
          _to address is 0.
    * It has a safe transfer function that allows tokens to be reclaimed if they are sent to the wrong address, unlike ERC-20 and ERC-1155
        * A key difference when using safeTransferFrom is that token transfers to other contracts may revert with the following message:
          ERC1155: transfer to non ERC1155Receiver implementer
        * It means that the recipient contract has not registered itself as aware of the ERC1155 protocol, so transfers to it are disabled to prevent tokens from being locked forever
            * As an example, the Golem contract currently holds over 350k GNT tokens, worth multiple tens of thousands of dollars, and lacks methods to get them out of there.
            * This has happened to virtually every ERC20-backed project, usually due to user error.
    * In order for our contract to receive ERC1155 tokens we can inherit from the convenience contract ERC1155Holder which handles the registering for us.
        * import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";
    * Semi-fungible tokens are like general admission concert tickets.
        * They are interchangeable and can be sold for money before the show (fungible)
        * But after the show they lose their pre-show value and become collectibles (non-fungible)
    * The standard provides two functions, balanceOfBatch and safeBatchTransferFrom, that make querying multiple balances and transferring multiple tokens simpler and less gas-intensive.
    * This is why its balanceOf function differs from ERC20’s and ERC777’s: it has an additional id argument for the identifier of the token that you want to query the balance of.
        * This is similar to how ERC721 does things, but in that standard a token id has no concept of balance: each token is non-fungible and exists or doesn’t.
        * The ERC721 balanceOf function refers to how many different tokens an account has, not how many of each. On the other hand, in ERC1155 accounts have a distinct balance for each token id, and non-fungible tokens are implemented by simply minting a single one of them.
    * use case
        * blockchain-based decentralized games, as games need coins and collectibles
        * ERC-1155 can be employed for creating and managing digital art and collectible tokens with different levels of rarity, editions, and properties.
    * Before
        * In a game with 100,000 items that means 100,000 smart contracts!
            * As ERC-1155 developer Witek Radomski pointed out, that's like needing a different phone for each app you use
            * This means if you wanted to send a sword to one friend, a shield to another, and 100 gold coins to both, you could do so in only one transaction.
        * This limitation meant that if someone wanted to transfer, say, USDC (ERC-20) and a CryptoKitties NFT (ERC-721), they would need to execute multiple transactions, which was inefficient and expensive.
        * ERC1155, if a use case needed both ERC20 (fungible) and ERC721 (non-fungible) tokens, then separate contracts were required to achieve this
    * allows for multiple NFT collections to be launched in just one smart contract instead of creating a different contract for each collection
    * batch transfer of tokens is also possible instead of transferring a token to a single address in previous standards.
        * This means that any number of items can be sent in a single transaction to one or more recipients, reducing transaction costs and complexity.
    * is a multi-token standard that allows the creation of fungible, non-fungible, and semi-fungible tokens all in one contract
    * It can save costs by managing tokens in batches (approval, transfer and balance) instead of individually
    * fungibility-agnostic token standard
    * allows multiple token to be represented by a single contract, regardless of fungibility
    * Suppose a developer wants to develop an NFT game. They plan to create one fungible token as the in-game currency and multiple non-fungible tokens for unique in-game assets such as skins, guns, merchandise, etc. If they use ERC-20 and ERC-721 standards, they would have to write new smart contracts to support every new type of asset they create. However, using ERC-1155 would enable them to write just one contract to support all kinds of tokens they want to have in the game.
    * ERC-1155 Multi Token Standard allows for each token ID to represent a new configurable token type, which may have its own metadata, supply and other attributes.
    * ERC1155 interface.
      safeTransferFrom
      safeBatchTransferFrom
      balanceOf
      balanceOfBatch
      setApprovalForAll
      isApprovedForAll
    * Events
      TransferSingle
      TransferBatch
      ApprovalForAll
      URI
    * Smart contracts MUST implement all of the functions in the ERC1155TokenReceiver interface to accept transfers.
        * onERC1155Received
        * onERC1155BatchReceived
* ERC165
    * If standards are developing and evolving over time, then ERC721 version 0.0.1 (a number I just made up) may have an interfaceID of 0x9f40b779 (which is the value of InterfaceID_ERC721 in the contract you provided). However, version 0.0.2 may add, change, or remove a function, which would completely change the interfaceID to something else.
        * So as long as you specify that your contract complies to ERC721 0.0.1, someone else can look up the interface, and check it against your contract.
    * So the very short answer to your question is, you shouldn't be checking supportsInterface against a single function, but rather against the whole interface.
    * The idea is that anyone can find the specification for the interface, and just check the interfaceID of that interface against your contract.
    * play a vital role in enabling seamless interactions between smart contracts and DApps
    * before
        * determining a smart contract’s supported interfaces was a challenging and gas-consuming process
        * some interaction might involve sending test transactions to the contract and observing the behavior
            * if the contract didn't support the desired interface, the transaction would fail or return an unexpected result
    * address the need for a standardized way of querying smart contracts to determine which interfaces or functionalities they support
    * interfaces are not explicitly represented on the blockchain
        * used by developers during the coding and development process
        * applications must usually simply trust they are not making an incorrect call
            * contract declaring its interface can be very helpful in preventing errors
    * accounts simply declare their interfaces
        * they are not required to actually implement them
        * must not be relied on for security
    * is a standard to detect and publish what interfaces a smart contract implements
    * it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with
    * interface has a single selector that can be calculated from the functions it implements
        * is defined as the XOR of all function selectors
        * `type(interface).interfaceId` returns the same as the interface selector
    * use case
        * we want to interact with a contract but we don't know if it supports an interface such as ERC20 or ERC721
        * example: OpenSea - NFT Marketplace
            * uses ERC165 to check if a given contract supports the ERC721 standard, which is the most common standard for non-fungible tokens
            * if a contract doesn't support ERC721 (as indicated by the supportsInterface call), OpenSea will handle it differently,

## openzeppelin
* “ The following is an example of enclosing a token transfer call and an approve call within the require() function:”
  * “require(ERC20(tokenAddress).transferFrom(from, to, value));”
  * “OpenZeppelin provides the SafeERC20.sol contract to ensure the safety of these calls; it is helpful to protect the contract from unintended behavior.”
* “ReentrancyGuard: Using the nonReentrant modifier in the buyTokens() function to prevent reentrancy attacks.
* “By using the WhitelistCrowdsale.sol contract, you can allow ether to be received from known/whitelisted addresses; other addresses cannot send ether to the contract”
* “Let's look at where these contracts can be used:
  * validation/CappedCrowdsale.sol: A crowdsale with an upper limit for the total wei or ether contribution also known as hard-cap
  * validation/IndividuallyCappedCrowdsale.sol: A crowdsale with individually capped upper limit of wei investments
  * validation/PausableCrowdsale.sol: Allows investment only when it isn't paused by PauserRole
  * validation/TimedCrowdsale.sol: A crowdsale that opens and accept ether for a specified duration of time
  * distribution/FinalizableCrowdsale.sol: Allows a special action to be triggered when crowdsale is over
  * distribution/PostDeliveryCrowdsale.sol: A crowdsale that allows its investors to withdraw their tokens only after it finishes
  * emission/AllowanceCrowdsale.sol: A crowdsale in which another wallet contains tokens and allowance is provided to the crowdsale contract so that it can deliver the tokens to the investors
  * emission/MintedCrowdsale.sol: A crowdsale in which new tokens are minted only when investors send ether to the contract
  * price/IncreasingPriceCrowdsale.sol: A crowdsale that increases the rate of the token linearly according to the time”
* “When all of the tokens that have been created on the Ethereum blockchain follow the same standard APIs, it becomes easy for different web and mobile cryptocurrency wallets to support these tokens”
* “The cryptocurrency exchanges support trading of tokens on their exchange”
  * “If all of the tokens support this ERC20 standard, it would be easy for these exchanges to integrate and it would support trading.”
  * “Apart from the cryptocurrency wallets and exchanges, it is also easy for a decentralized exchange to support these standard tokens as they would have to call the ERC20 standard APIs from their smart contracts”
    * “For example, EtherDelta, IDEX, and KyberNetwork are some decentralized exchanges built on top of Ethereum blockchain and they support trading of ERC20 tokens.”
* “The ERC20 standard only defines the interface APIs—the implementation should be written according to your needs”
  * “The most updated and best place to look for the ERC20 implementation is the OpenZeppelin library of Solidity smart contracts”
* “allowed is a nested mapping of two Solidity mapping data types. In the ERC20 standard specification, it is possible for a token holder, X, to assign some allowances to another account, Y, so that Y is allowed to take the approved number of tokens from the token balance of X”
* “The developers must know that there are two types of transfer() functions.”
  * “One is used on the address data types to transfer the ether to that address from the contract”
    * “address(toAddress).transfer(amount);”
  * “The second type is the function defined by the ERC20 standard.”
    * “ERC20(TKNContractAddress).transfer(toAddress, amount);”
* “Coin: A native digital asset or cryptocurrency of a blockchain is called a coin. For example, the bitcoin blockchain has its native cryptocurrency asset, bitcoin (symbol: BTC). The Ethereum blockchain has its native cryptocurrency asset, ether (symbol: ETH), which is required in the blockchain to perform any transaction.”
* “Token: A digital asset or cryptocurrency that is built on top of an existing blockchain is called a token. For example, Maker (symbol: MKR) and Augur (symbol: REP) are ERC20-compliant tokens and are built on the Ethereum blockchain using Solidity smart contracts.”
* “There are two types of exchanges:”
  * “Centralized Exchange: On a centralized exchange, you have to send your cryptocurrency coin or token to the exchange's account. Then, they allow you to trade on their platform.”
    * “As the coins and tokens are held on an exchange's account, there might be a trust issue.”
    * “It is also possible that if the exchange's account is hacked, you will lose your cryptocurrencies”
    * “Binance and Bitfinex are some examples of centralized exchanges”
  * “Decentralized Exchange: On a decentralized exchange, you do not have to send your cryptocurrency coin or token to exchange's account.”
    * y“our coins are kept in your wallet only.”
    * “Instead, you directly trade via exchange platform; coins aren't even kept on the exchange platform”
    * “KyberNetwork, IDEX, and EtherDelta are some of the decentralized exchanges that are available for P2P trading.”
* “Ethereum has its own native currency, ether, which is not ERC20-compliant.”
* https://nfting.medium.com/the-history-of-cryptokitties-ethereums-first-official-gaming-application-499729e50794
* https://betterprogramming.pub/cryptokitties-smart-contract-breakdown-2c3c250d33f6
* https://spectrum.ieee.org/cryptokitties
* OpenZeppelin
    * is an open-source library of protocols, templates, & utilities for smart contract development
    * includes implementations for token standards, flexible role-based permissioning schemes, & reusable components
    * OpenZeppelin library offers implementations for ERC20 , ERC721, & ERC1155